 1、类的访问控制
	1)public:公有的
		 所有的类都可以访问
	
	2）protected:受保护的类
		本类可以访问
		同一个包中的其他类可以访问
		同一个包或不同包里的子类可以访问
	
	3)默认的：不写修饰符
		本类可以访问 
		同一个包的其他类(包括其子类)可以访问
		
	4）private:私有的
		本类可以访问 
		其他都不能访问
		
						Public成员	Protected成员	默认成员	 Private成员
同一类中可见				是			是				是			是
同一个包中对子类可见		是			是				是	
同一个包中对非子类可见	是			是				是	
不同包中对子类可见		是			是		
不同的包中对非子类可见	是			

2、成员变量和成员方法的访问控制
	1)public:
	本类的对象，还有其他子类的对象可访问
	
	2)protected:
	本类的对象，同一个包或不同包中的子类的对象可以访问
	
	3）默认的：
	本类的对象可以访问 
	同一个包的子类对象可以访问
	
	4）private:
	只能在本类中访问
	
3、修饰符使用基本经验：
・	1）大部份类都用public，如果包含main方法的必须是public
	2)如果一个类想被同一个项目的不同包使用，则用protected
	3）如果这个类只想被同一个包使用，则用默认的
	4)如果一个类不想被其他任何类使用，则用private
	
	方法和变量：
		1）一个类的实例变量通常都设置为private私有的，同时提供一个访问该变量的方法和一个设置该变量的方法
		2) 如果一个类想被同一个项目的不同包使用，则用protected, 可以直接用对象来访问
		3）常量通常设置为public的  ： public static final int AGE = 100;
		
4、private修饰的成员变量只能在本类中用本类的对象直接访问，在其他类中不能用类的对象直接访问
	使用getter和setter方法来完成对私有属性的获取和赋值
	
	封装：隐藏属性，只提供方法来访问，类的封装
	1）隐藏类的实现细节
	2）让使用者只能通过指定的方法访问数据，可以方便加入控制逻辑，限制不合理的操作，保证数据的安全性
	3）便于修改，增强代码可维护性
	4）可进行数据检查
	
5、JavaBean规范
	所有实例变量都是私有的，并提供实例变量的getter和setter方法进行访问
	set|get+实例变量的名称，把实例变量的首字母变成大写
	
6、内部类
	在一个类中可以定义public, 默认的，protected, private修饰的内部类
	如何实例化：OuterClass.InnerClass innerClass = outerClass.new InnerClass();
	
	内部类对象保存了一个对外部类对象的引用: 内部类可以使用外部内中的成员变量，成员方法
	
	InnerClass.this表示对内部类的对象引用
	OutterClass.this表示对外部类的对象引用
	
	可直接在外部类的方法中实例化内部类的实例 
	
	
	静态内部类只能访问外部类的静态成员变量或静态方法 
	静态内部类中可以声明static成员，而非静态内部类不能声明static成员
	
	局部内部类：放在方法里的类，只能用默认修饰符，不能用public, protected, private
		不能在方法里定义局部内部类之前实例化局部内部类的对象，要先定义好，再使用
		public void innerClass() {
		
			// InnerClass ic = new InnerClass(); // 不能在方法里定义局部内部类之前实例化局部内部类的对象
			
			final int a = 10; // 使用final修饰，不能在局部内部类中修改， 保证数据安全性
			
			class InnerClass {
				
				public void modify() {
					System.out.println(a);
					int b = a + 10;
					// a = 20; // 局部内部类不能去修改包含此局部内部类方法里的局部变量
				}
				
			}
			
			InnerClass ic = new InnerClass();
			ic.modify();
			
			System.out.println(a);
		}

7、类的继承（父类派生出子类）
	类A继承自类B，类A可以同时继承类B的成员方法和成员变量， 不继承类B的构造方法
	称类B为父类，类A为子类
	
	子类可以拥有自己的属性和方法，但是不会继承父类的属性的值
	
	public class B {
		String name;
		int age;
		
		public void read() {}
	}
	
	public class A extends B {
	
		int height;
		
		public void run() {}
	
	}
	// 此时的A有name, age属性，有read()方法 
	// 同时还可以有自己的height属性, run()方法
	
	注意：
		没有extends，默认父类为Object
		只能有一个父类，即单继承
		子类继承父类的全部成员（方法和属性），除private的成员/方法
		
8、继承的特点：
	1）通过继承可以简化类的定义

	2）JAVA只支持单继承，不允许多重继承。而接口可以多继承
	
	3）可以有多层继承；类B继承类A；类C继承类B；
	
	4）子类继承父类的成员变量和成员方法，但不继承父类的构造函数，
	但在子类的构造方法中可以使用super(参数列表)调用父类的构造方法。
	
	5）如果子类的构造方法中没有显示的调用父类构造方法，也没有使用this关键字调用自己的其他构造方法，
	那么在产生子类实例对象时JVM自动调用父类无参数的构造方法。
		
9、方法的执行过程
	1）父类静态方法块
	2）子类静态方法块
	3）父类的动态方法块
	4）父类无参构造方法执行
	5）子类的动态方法块
	6）子类构造方法执行
	
10、方法重写（方法的覆盖）
	子类重新实现父类中定义的某个方法（子类覆盖父类中的某个方法）， 方法内部的实现不一样
	
	如果想要调用父类中的被重写的方法，则使用super来方法
	
11、final关键字
	被final修饰的类不能被继承
	被final修饰的方法不能被重写
	被final修饰的变量为常量，不能被修改
	
	常量定义时：public static final int AGE = 20;  习惯把static 放在 final 前
	
12、父类和子类的使用
	1）子类对象可以被视为是其父类的一个对象；
	2）父类对象不能当成是其某一个子类的对象；
	3）如果一个方法的形式参数定义的是父类对象，那么调用这个方法时，可以使用子类对象作为实际参数；
	4）如果父类对象引用指向的实际是一个子类对象，那么这个父类对象的引用可以用强制类型转换转化成子类对象的引用
	
13、多态
	同一个方法可以有多种不同的实现
	
	1）通过继承和方法重写实现多态
	
	2）通过抽象类来实现多态
	3）通过接口来实现多态
	
14、java.lang.Object类的分析
	1)toString();
		public String toString() {
        	return getClass().getName() + "@" + Integer.toHexString(hashCode());
    	}
    	返回某个对象所对应的类的全限定名+@+此对象在内存中的地址
    	
    	大部分情况下需要重写toString方法 
    2)equals方法
    	public boolean equals(Object obj) {
	        return (this == obj);
	    }
	    
	    ==:如果对基本数据类型，则表示比较其数据值是否相等
	    	如果对对象进行==比较，则是判断两个对象所指向的引用是否相等
	     	
	    一个类变量指向一个对象，就表示该类变量引用这个对象.
	    
	    需要去重写equals方法来对对象所持有的属性值进行相等判断，如String类的equals方法 是判断每个字符是否相等
	    假设有User类，如果User对象的id属性相等，我们就认为是同一个人，这个时候就要重写equals方法，对id属性进行判断，如果id相等，则返回true
	 如何重写equals方法？请参考MyObject类的equals方法
	
	3)hashCode方法
		public native int hashCode(); // 表示该方法为本地方法，用C语言实现的方法
		
		返回对象在内存中的地址
		
		问题：有没有必要重写hashCode方法？
		
15、补充，如何附加源代码
	1）鼠标光标停留在String字符串上，按F3键
	2）如果已经附加过源代码，则直接显示出源代码
	3）如果没有附加源代码，则弹出一个由eclipse反编译的代码，找到Attach Source按钮
	4）点击Attach Source按钮，弹出一个小框框
	5）选择External File， 再点击右侧的External File
	6）在弹出的文件选择窗口中找到jdk安装目录下的src.zip
	
16、抽象类：
	在普通类定义时，class前面加abstract关键字
	1）抽象类可以像普通类一样添加方法，包括构造方法和实例方法, 
		但是不能被实例化，不能直接由抽象类实例化对象来调用实例方法
	2）抽象类不能被实例化，哪怕添加了构造方法
	3）可以在抽象类中定义抽象方法(只能出现在抽象类中)
		a. 在返回值类型前添加abstract关键字
		b. 抽象方法只允许声明，不能有实现，直接由;结束，如public abstract void read();
		c. 如果一个方法声明为abstract抽象方法，就意味着类要改写成抽象类
	4）通过非抽象类继承自一个抽象类，则该子类必须实现抽象类中的抽象方法
	5）由子类继承自抽象类，则必须实现抽象方法，抽象方法前加@Override表示该方法是被重写的方法
	
	什么时候用抽象类？
	当想要让子类可以有某个方法的不同实现，并且所有子类都必须有去实现这个方法

	抽象类提供的普通成员方法只能由抽象类的子类来使用
	抽象类提供的抽象方法，只能由抽象类的子类来实现并使用
	
17、接口（特殊的抽象类）
	public interface Activity {}，使用interface关键字表示创建一个接口
	1）接口内的方法是抽象方法，必须由实现该接口的子类来实现抽象方法
	2）接口内的方法都是抽象方法，不需要添加abstract关键字，不需要实现，直接由;结束
	3）必须指定类来实现某个接口，则该类中必须实现接口中声明的所有方法，如public class StudentActivity implements Activity{}
		使用implements实现接口，implements关键字后只能是接口
	4）接口里定义的变量默认是常量，必须指定初始值
		接口里的常量只能是public, 默认的，static, final来修饰
	5）接口可以继承另外一个接口
	6）一个类可以实现多个接口，每个接口间用, 隔开
	7）接口可以多继承
	
18、引用方式
	可以用父类，抽象类来引用父类或抽象类的子类，用接口来引用实现了该接口的类
	
19、适配器模式(Adapter)
	增加一个抽象类来实现接口，想要实现接口内部部分方法的类只需要继承自该抽象类，而不需要直接实现此接口
	User.java, UserService.java, UserServcieAdapter.java, UserServiceImpl.java, AdminServiceImpl.java
	如果一个类是Adapter，则最好以Adapter结尾




设计模式（23种）
	
	

	