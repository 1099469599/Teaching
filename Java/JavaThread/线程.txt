1、进程和线程
	是指一个应用程序的执行，该应用程序的所有资源，比如图片，数据等都由进程所拥有
	进程包含一个或者多个线程，由线程来使用图片，数据等资源。
	线程是一个独立的程序体，多个线程可以并发执行（同一时间段，多个线程可以被执行），但是不是指绝对相等的时刻。
	cpu中央处理器会自动地分配相应的时间给每一个线程，比如1-10ns分配给线程A，其他线程在休眠。11-20ns分配给线程B，其他线程在休眠
	
	进程占用资源大，通信难
	线程占用资源小，通信易
	
	线程的特点：
	1）线程也称为执行部分，是可以同时运行的独立过程。

	2）线程有开始、中间和结束部分，即有一定的生命周期。

	3）同一个类的多个线程是共享一块内存空间和一组资源。 

	4）线程不能作为具体的可执行命令体存在。最终用户不能直接执行线程，线程只能运行在程序中

2、java.lang.Thread implements Runnable表示一个线程类
	1）自定义一个类，继承自Thread类，则说明自定义的类是一个线程类
	2）必须重写public void run(){}方法 ， 所有需要在线程中跑的代码都放到该方法内
	3）实例化自定义的线程类
	4）调用start()方法启动线程，如果有多个线程类的实例，则调用每个线程类对象的start方法，jvm会自动分配cpu时间给每一个线程
	
3、java.lang.Runnable接口，表示线程的接口，java.lang.Thread也是继承自该接口
	所有实现了该接口的类都是线程类，必须重写public void run(){}方法
	
	1）自定义一个类，实现java.lang.Runnable接口
	2）重写public void run(){}方法，所有需要用线程来跑的代码都放到该方法内部
	3）实例化实现了Runnable接口的类
	4）借助Thread类来创建可以调用start方法的线程 
		new Thread(实现了Runnable接口的类的对象);
	5）由第四步中创建的Thread类的实例调用 start()方法 
	
4、线程的执行过程
	1）调用start()方法启动线程
	2）调用该已经启动的线程的run()方法，此run()方法获取的cpu时间由jvm自动分配
	3）run方法内部的逻辑结束后，则线程结束
	
5、线程的状态
	1）新建（new）：线程对象已经建立，但还没有启动，所以他不能运行。
	2）就绪（runnable）：start后进入该种状态下，只要调度程序把时间片分配给线程就可以执行，
		也就是说任何时刻它可以执行也可以不执行，不同于死亡和阻塞状态
	3）运行状态（running):就绪状态的线程获得了cpu时间，则进入到运行状态
	4）死亡（dead）：线程死亡通常是从run方法返回的，在Java2放弃stop前也可以通过该方法实现，但容易让程序进入不稳定状态
	5）阻塞（blocked）：线程能够运行，但有某个条件阻止他的运行。处于阻塞状态的线程调度机制将忽略线程，
		直到线程重新进入就绪状态，它才有可能执行操作
		
6、推荐使用实现Runnable的方法	
	1）单继承问题，如果自定义的类还需要继承自其他类，则必须实现Runnable接口
	2）使用这种方式的开销小
	
7、线程的优先级
	每个线程都有一个优先级，高优先级线程的执行优先于 低优先级线程
	java.lang.Thread类的setPriority(int i)， i是指优先级，从1-10由低到 高，Thread.MIN_PRIORITY指1，Thread.NORMAL_PRIORITY指普通优先级，
	是默认的优先级，Thread.MAX_PRORITY最高优先级
	
8、守候线程
	setDaemon(true)表示设置为守护线程
	setDaemon(false)表示设置为正常的用户线程
	将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。必须至少有一个用户线程
	isDaemon()返回某个线程是否为守护线程
	
	public static void main(String[] args) main方法也是一个线程
	
9、几个方法：
	interrupt()中断指定的线程，从休眠状态转化为运行状态
	yield()
	public static void yield() 
  	方法为静态方法，只能影响当前正在运行的线程
  	join()等待调用该方法的线程执行完毕
  	
10、线程安全问题(资源同步)
	多个线程同时操作同一个数据，则可能造成数据错误
	
	如何解决：
	1）让方法是同步方法，在一个线程的方法使用完资源后，另外的线线程的同一个方法才会被执行
		在方法前面添加synchronized关键字（方法级的同步）
	2）把需要对同一个资源操作的代码放在如下代码块中
	synchronized(Object.class) {
		// 对资源操作的代码
	}
	（代码级的同步，效率会更好）
	
	以上解决方案相当于一个线程进入操作，则立马上锁，其他线程没办法进入到同样的方法或代码块中，必须等待已经上锁的线程解锁后，
	其他线程才能进入到该方法或代码块
	
	什么情况下注意线程同步：
	如果有多个线程需要对共享的资源进行操作，则需要考虑使用同步

11、sleep休眠  interrupt中断
	wait等待 notify唤醒, notifyAll
	stop 没办法重新唤起
	suspend挂起 resume恢复	
	
	sleep wait suspend yield都可以让线程暂时停止
	
